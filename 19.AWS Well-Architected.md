# 18. AWS Well-Architected Full Demo <!-- omit in TOC -->

# 1. Estructura del proyecto
## 1.1. Root
## 1.2. Network
## 1.3. SecurityGroups
## 1.4. Ec2
## 1.5. LoadBalancer
## 1.6. DNS
## 1.7. AutoscalingGroups

- Cada módulo requiere de una carpeta con sus archivos.
- Usar tf validate, para comprobar las configuraciones.

# 2. Configurar el proveedor AWS y la máquina virtual con las credenciales.
- usar la region: us-east-1
- usar las credenciales provistas para el laboratorio

# 3. Crear las variables del proyecto
## 3.1. Variables globales (variables.tf)
- lab_name: type: string, description: "Nombre del estudiante", condición: no menor de 3 caractéres
- key_name: type: string, description: "Nombre de la llave SSH para conectar con el Bastion host"
- cidr_block: type: string, descripcion: bloque de IP's para la VPC
- public_cidr_block: type: string, description = "Bloque de IP's para la subnet pública"
- private_cidr_block: type: string, description = "Bloque de IP's para la subnet privada"
- public_zone: type: string, description = "Zona de acceso público"
- private_zone: type: string, description = "Zona de acceso privado"
## 3.2. Valores por defecto (terraform.tfvars)
- cidr_block = "10.0.0.0/16"
- public_cidr_block  = "10.0.1.0/24"
- private_cidr_block = "10.0.2.0/24"
- public_zone = "us-east-1a"
- private_zone = "us-east-1b"

# 4. Módulo Network
## 4.1. Crear VPC
> [VPC](https://github.com/cachac/TerraformLabs/blob/main/18.Workspaces.md#82-servertf)

- usar el CIDR: var.cidr_block
- Agregarle el tag: Name = "VPC ${var.lab_name}"

## 4.2. Crear subnet pública
- usar el CIDR: var.public.cidr_block
- zona: var.public_zone
## 4.3. Crear subnet privada
- usar el CIDR: var.private.cidr_block
- zona: var.private_zone

## 4.4. Crear tablas de enrutamiento y gateways
Para dividir el tráfico de las subnets públicas y privadas se debe configurar:
### 4.4.1. Internet Gateway
Para la entrada de tráfico desde internet hacia la Subnet pública
```tf
resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.vpc.id
}
```
### 4.4.2. NAT Gateway
Para la salida de tráfico de la subnet privada por medio de la subnet pública
```tf
resource "aws_eip" "nat_elastic_ip" {
  vpc = true
}

resource "aws_nat_gateway" "ngw" {
  depends_on = [aws_internet_gateway.igw]

  allocation_id = aws_eip.nat_elastic_ip.id
  subnet_id     = aws_subnet.public_subnet.id
}
```

### 4.4.3. Public Route Tables
```tf
resource "aws_route_table" "rt_igw" {
  depends_on = [aws_internet_gateway.igw, aws_vpc.vpc]
  vpc_id     = aws_vpc.vpc.id
}

# route from 0.0.0.0/0 to igw
resource "aws_route" "publicRoute" {
  depends_on             = [aws_route_table.rt_igw]
  route_table_id         = aws_route_table.rt_igw.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.igw.id
}

# associations
resource "aws_route_table_association" "public_subnet_association_a" {
  subnet_id      = aws_subnet.public_subnet.id
  route_table_id = aws_route_table.rt_igw.id
}
```

### 4.4.4. Private Route Tables
```tf
# route table
resource "aws_route_table" "rt_nat" {
  depends_on = [aws_vpc.vpc, aws_nat_gateway.ngw]

  vpc_id = aws_vpc.vpc.id
}

# route from 0.0.0.0/0 to igw
resource "aws_route" "routeNat" {
  depends_on = [aws_route_table.rt_nat]

  route_table_id         = aws_route_table.rt_nat.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_nat_gateway.ngw.id
}

# associations
resource "aws_route_table_association" "private_subnet_association_a" {
  subnet_id      = aws_subnet.private_subnet.id
  route_table_id = aws_route_table.rt_nat.id
}
```

## 4.5. Exportar los recursos:  aws_vpc.vpc - aws_subnet.public_subnet - aws_subnet.private_subnet
Es necesario exportar los recursos para ser utilizado en los demás módulos del laboratorio.
```tf
output "vpc" {
  value = aws_vpc.vpc
}
output "public_subnet" {
  value = aws_subnet.public_subnet
}
output "private_subnet" {
  value = aws_subnet.private_subnet
}
```
> En adelante deberá interpretar cuales recursos deben exportarse de cada módulo.
# 5. CheckPoint
- llamar el módulo Network en ./main.tf
- pasar las variables necesarias al módulo
- aplicar la configuración del módulo

# 6. SecurityGroups

## 6.1. Crear una variable (variables.tf) que reciba el VPC del punto anterior
```tf
variable "vpc" {
	type = any
	description = "VPC del laboratorio"
}
```
## 6.2. Bastion Host
- Ver el ejemplo :
> [aws_security_group](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/security_group)
- permite el tráfico SSH, puerto 22 tcp de entrada desde "0.0.0.0/0"
- permite todo el tráfico de salida
- usar el id de la vpc creada en el paso anterior

Ejemplo Ingress a puerto 22:
```tf
  from_port   = 22
  to_port     = 22
  protocol    = "tcp"
  cidr_blocks = ["0.0.0.0/0"]
```

## 6.3. Public
- permite el tráfico HTTP, puerto 80 de entrada desde "0.0.0.0/0"
- permite el tráfico HTTPs,puerto 443 de entrada desde "0.0.0.0/0"
- permite todo el tráfico de salida
- usar el id de la vpc creada en el paso anterior
## 6.4. Private
- permite el tráfico SSH, puerto 22 de entrada desde el security group del Bastion Host
- permite el tráfico HTTP, puerto 80 de entrada desde el security group público
- permite el tráfico HTTPs,puerto 443 de entrada desde el security group público
- permite todo el tráfico de salida
- usar el id de la vpc creada en el paso anterior

# 7. CheckPoint
- llamar el módulo SecurityGroups en ./main.tf
- pasar la variable vpc al módulo
- aplicar la configuración del módulo

# EC2

## Crear llave SSH y exportarla a un archivo local (key.tf)
>[key_pair](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/key_pair)
Esta llave se utilizará para acceder al Bastion host
aws_key_pair: crea una llave .pem en AWS y está llave se le asigna a las VM para su acceso por SSH
```tf
resource "tls_private_key" "privateKey" {
  algorithm = "RSA"
  rsa_bits  = 4096
}

resource "aws_key_pair" "ec2_key" {
  key_name   = var.key_name
  public_key = tls_private_key.privateKey.public_key_openssh
}

resource "local_file" "key_file" {
  content  = tls_private_key.privateKey.private_key_pem
  filename = "key.pem"
}
```

## Crear recurso data (data.tf) con la imagen del sistema operativo Ubuntu 20.04
```tf
data "aws_ami" "ubuntu" {
  most_recent = true

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }

  owners = ["099720109477"] # Canonical
}
```

## Crear una máquina virtual de acceso por puerto 22 (SSH)
Esta en la VM que permite la entrada a nuestra infraestructura.
Por cuestiones de seguridad, es la única VM que permite el acceso libre desde Internet.

> [ec2](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance)

- instancia t3a.nano
- ami: utilizar el id del ami creada en el punto anterior
```tf
ami         		= data.aws_ami.ubuntu.id
```
- subnet pública
- security group bastion
```tf
vpc_security_group_ids      = [var.sgBastion.id]
```
- [asociar una ip pública](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance#associate_public_ip_address)
 ```tf
 associate_public_ip_address = true
 ```
- tag nombre: concatenar la palabra "bastion-" con la variable "lab_name"
```tf
	tags = {
		Name = "bastion-${var.lab_name}"
	}
```
- configuración de acceso por SSH
```tf
key_name                    = aws_key_pair.ec2_key.key_name
```
## Exportar ip pública de la VM
> [ec2_public_ip](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance#public_ip)


# En ./output.tf crear una salida que muestre el comando ssh para conectar con la IP pública del Bastion Host
```tf
output "bastion_host" {
  value       = "ssh -i key.pem ubuntu@${module.ec2.BASTION_PUBLIC_IP}"
  description = "bastion SSH"
}
```
# Checkpoint
- Configurar el módulo de EC2 y pasar las variables requeridas.
- Ingresar al Bastion Host
 ```vim
 ssh -i KEY_NAME ubuntu@PUBLIC_IP
 ```
 > la llave ssh debe modificar sus permisos: chmod 400 KEY_NAME
